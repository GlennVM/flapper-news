
/*!
 * Module dependencies.
 */

<<<<<<< HEAD
var STATES = require('./connectionstate')
=======
var EventEmitter = require('events').EventEmitter;
var STATES = require('./connectionstate');
>>>>>>> develop

/**
 * Abstract Collection constructor
 *
 * This is the base class that drivers inherit from and implement.
 *
 * @param {String} name name of the collection
 * @param {Connection} conn A MongooseConnection instance
 * @param {Object} opts optional collection options
 * @api public
 */

<<<<<<< HEAD
function Collection (name, conn, opts) {
=======
function Collection(name, conn, opts) {
>>>>>>> develop
  if (undefined === opts) opts = {};
  if (undefined === opts.capped) opts.capped = {};

  opts.bufferCommands = undefined === opts.bufferCommands
    ? true
    : opts.bufferCommands;

  if ('number' == typeof opts.capped) {
    opts.capped = { size: opts.capped };
  }

  this.opts = opts;
  this.name = name;
<<<<<<< HEAD
  this.conn = conn;
  this.queue = [];
  this.buffer = this.opts.bufferCommands;
=======
  this.collectionName = name;
  this.conn = conn;
  this.queue = [];
  this.buffer = this.opts.bufferCommands;
  this.emitter = new EventEmitter();
>>>>>>> develop

  if (STATES.connected == this.conn.readyState) {
    this.onOpen();
  }
<<<<<<< HEAD
};
=======
}
>>>>>>> develop

/**
 * The collection name
 *
 * @api public
 * @property name
 */

Collection.prototype.name;

/**
<<<<<<< HEAD
=======
 * The collection name
 *
 * @api public
 * @property collectionName
 */

Collection.prototype.collectionName;

/**
>>>>>>> develop
 * The Connection instance
 *
 * @api public
 * @property conn
 */

Collection.prototype.conn;

/**
 * Called when the database connects
 *
 * @api private
 */

<<<<<<< HEAD
Collection.prototype.onOpen = function () {
=======
Collection.prototype.onOpen = function() {
>>>>>>> develop
  var self = this;
  this.buffer = false;
  self.doQueue();
};

/**
 * Called when the database disconnects
 *
 * @api private
 */

<<<<<<< HEAD
Collection.prototype.onClose = function () {
=======
Collection.prototype.onClose = function() {
>>>>>>> develop
  if (this.opts.bufferCommands) {
    this.buffer = true;
  }
};

/**
 * Queues a method for later execution when its
 * database connection opens.
 *
 * @param {String} name name of the method to queue
 * @param {Array} args arguments to pass to the method when executed
 * @api private
 */

<<<<<<< HEAD
Collection.prototype.addQueue = function (name, args) {
=======
Collection.prototype.addQueue = function(name, args) {
>>>>>>> develop
  this.queue.push([name, args]);
  return this;
};

/**
 * Executes all queued methods and clears the queue.
 *
 * @api private
 */

<<<<<<< HEAD
Collection.prototype.doQueue = function () {
  for (var i = 0, l = this.queue.length; i < l; i++){
    this[this.queue[i][0]].apply(this, this.queue[i][1]);
  }
  this.queue = [];
=======
Collection.prototype.doQueue = function() {
  for (var i = 0, l = this.queue.length; i < l; i++) {
    this[this.queue[i][0]].apply(this, this.queue[i][1]);
  }
  this.queue = [];
  var _this = this;
  process.nextTick(function() {
    _this.emitter.emit('queue');
  });
>>>>>>> develop
  return this;
};

/**
 * Abstract method that drivers must implement.
 */

<<<<<<< HEAD
Collection.prototype.ensureIndex = function(){
=======
Collection.prototype.ensureIndex = function() {
>>>>>>> develop
  throw new Error('Collection#ensureIndex unimplemented by driver');
};

/**
 * Abstract method that drivers must implement.
 */

<<<<<<< HEAD
Collection.prototype.findAndModify = function(){
=======
Collection.prototype.findAndModify = function() {
>>>>>>> develop
  throw new Error('Collection#findAndModify unimplemented by driver');
};

/**
 * Abstract method that drivers must implement.
 */

<<<<<<< HEAD
Collection.prototype.findOne = function(){
=======
Collection.prototype.findOne = function() {
>>>>>>> develop
  throw new Error('Collection#findOne unimplemented by driver');
};

/**
 * Abstract method that drivers must implement.
 */

<<<<<<< HEAD
Collection.prototype.find = function(){
=======
Collection.prototype.find = function() {
>>>>>>> develop
  throw new Error('Collection#find unimplemented by driver');
};

/**
 * Abstract method that drivers must implement.
 */

<<<<<<< HEAD
Collection.prototype.insert = function(){
=======
Collection.prototype.insert = function() {
>>>>>>> develop
  throw new Error('Collection#insert unimplemented by driver');
};

/**
 * Abstract method that drivers must implement.
 */

<<<<<<< HEAD
Collection.prototype.save = function(){
=======
Collection.prototype.save = function() {
>>>>>>> develop
  throw new Error('Collection#save unimplemented by driver');
};

/**
 * Abstract method that drivers must implement.
 */

<<<<<<< HEAD
Collection.prototype.update = function(){
=======
Collection.prototype.update = function() {
>>>>>>> develop
  throw new Error('Collection#update unimplemented by driver');
};

/**
 * Abstract method that drivers must implement.
 */

<<<<<<< HEAD
Collection.prototype.getIndexes = function(){
=======
Collection.prototype.getIndexes = function() {
>>>>>>> develop
  throw new Error('Collection#getIndexes unimplemented by driver');
};

/**
 * Abstract method that drivers must implement.
 */

<<<<<<< HEAD
Collection.prototype.mapReduce = function(){
=======
Collection.prototype.mapReduce = function() {
>>>>>>> develop
  throw new Error('Collection#mapReduce unimplemented by driver');
};

/*!
 * Module exports.
 */

module.exports = Collection;
